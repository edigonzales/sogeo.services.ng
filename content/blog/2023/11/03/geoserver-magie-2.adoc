= GeoServer Magie #2 - More GetFeatureInfo witchcraft
Stefan Ziegler
2023-11-03
:jbake-type: post
:jbake-status: published
:jbake-tags: GeoServer,Freemarker,WMS,GetFeatureInfo
:idprefix:

https://geoserver.org/[_GeoServer_] war schon immer der WMS-Server der Herzen, also meines Herzens. Ganz zu Beginn (muss 2001 oder früher gewesen sein) hatten wir https://mapserver.org/[_MapServer_] erfolgreich im Einsatz. _GeoServer_ haben wir dann ein paar Jahre für das Herstellen von grossformatigen PDF verwendet. Zu guter Letzt sind wir dem Marketing von QGIS-Server erlegen und haben auch diesen WMS-Server in Betrieb genommen. Ein wichtiges Ziel bei der Einführung des neuen Web GIS Clients (2016 - 2018) war die Reduktion der WMS-Server auf einen. Die Wahl fiel auf QGIS-Server. Weil wir früher oder später beim Web GIS Client und sämtlichen Services und Umsystemen über die Bücher müssen, darf man sich _GeoServer_ wieder ins Gedächtnis rufen. 

Ich fand bei _GeoServer_ immer gut, dass bereits viel mitkommt, was wir bei unserer Lösung damals zusätzlich programmieren lassen mussten, z.B.

- Identity and Access Management
- GUI für die Administration 
- Layergruppen zu einem Einzellayer gruppiert
- Mächtige Konfigurationsmöglichenkeiten bei der GetFeatureInfo-Funktion

Und um diese Konfigurationsmöglichenkeiten geht es hier und jetzt. Ich habe bereits vor http://blog.sogeo.services/blog/2018/09/10/geoserver-magie-1.html[fünf Jahren davon geschwärmt] und bin immer noch fasziniert. Ich habe unsere Anforderungen an die Objektabfrage (die plusminus der GetFeatureInfo-Abfrage entspricht) rausgekramt und will wissen, wie das mit _GeoServer_ ginge?

Anforderungen:

- Aliasnamen: Die Attributnamen aus der Datenbank sollen überschrieben werden können.
- Attribute sollen ausgeblendet resp. nicht angezeigt werden können.
- Reihenfolge der Attribute muss konfigurierbar sein
- Attributewerte sollen formatiert werden können. Z.B. &laquo;true&raquo; soll zu &laquo;Ja&raquo; formatiert werden.
- Neue Attribute sollen hinzugefügt werden können, z.B. ein Link auf eine Fachanwendung. Der Link ist nicht in der Datenquelle vorhanden.
- Der hinzukonfigurierte Link soll zudem verwendet werden können, um einen Report-Service aufzurufen. Dem Report-Service muss die Objekt-ID und die geklickte Koordinate mitgeliefert werden können.
- Fotos (Link auf URL) sollen automatisch dargestellt werden (nur HTML-Output).
- Allfälliges JSON als Attributwert soll als Key-Value gerendert werden (nur HTML-Output).
- Templating Engine für sehr spezifische Outputs.
- Beliebige SQL-Query: Das Resultat einer beliebigen SQL-Query wird als Key-Value in der GetFeatureInfo-Antwort zurückgeliefert.
- Beliebige Businesslogik: Es wird selbst programmierter Code ausgeführt und das Resultat wird als Key-Value in der GetFeatureInfo-Antwort zurückgeliefert. Haben wir wenig überraschend wirklich nicht so gerne und noch weniger gerne als die SQL-Query.

**Templating Engine** 

Wahrscheinlich das Wichtigste gleich zu Beginn: GetFeatureInfo-Antworten werden für die Formate GeoJSON und HTML mittels https://freemarker.apache.org/[Freemarker Templates] https://docs.geoserver.org/stable/en/user/tutorials/freemarker.html[konfiguriert]. Somit ist die Basis für viel Einflussnahme gelegt. Die Templates können global, pro Workspace oder für einen spezifischen Layer definiert werden.

Wünschenswert ist natürlich ein möglichst generisches, globales Template herstellen zu können und nur für die absoluten Spezialfälle ein zusätzliches.

**Aliasnamen / Attribute ausblenden / Reihenfolge**

Diese drei Anforderungen können seit https://geoserver.org/announcements/2022/05/24/geoserver-2-21-0-released.html[Version 2.21.0] leicht umgesetzt werden: 

image::../../../../../images/geoserver-magie-p2/attributes01.png[alt="Customize attributes", align="center"]

Das Attribute &laquo;schoener_Stein&raquo; wird zu &laquo;Schöner Stein&raquo;. Mit den Pfeilen kann man die Reihenfolge ändern und dem roten Kreis, kann man Attribute entfernen. Hat jetzt noch Luft nach oben, was die Benutzerfreundlichkeit betrifft: Ich würde lieber ein Attribut visuell &laquo;disablen&raquo; und nicht löschen. Und die Reihenfolge möchte ich mit Drag 'n' Drop verändern.

Wenn man die Attributnamen verändert, muss man unbedingt wissen, dass der XML/GML-Output nicht mehr zwingend funktioniert. _GeoServer_ sendet eine WFS-FeatureCollection zurück. Attribute landen in XML-Tags. Was natürlich mit Umlauten und Leerzeichen nicht mehr funktioniert. Die erlaubten Antwortformate lassen sich aber in _GeoServer_ konfigurieren.

**Attributwerte formatieren**

Inbesondere bei Boolean-Werten hat man das Bedürfnis diese anders als true/false zu rendern. Hier helfen uns die https://docs.geoserver.org/main/en/user/filter/function_reference.html[Filter-Funktionen]. Mit diesen lassen sich die Attributwerte verändern. Im folgenden Beispiel wird zuerst geprüft, ob der Werte null ist und anschliessend findet das eigentliche Umwandlung in den &laquo;schönen&raquo; String statt:

image::../../../../../images/geoserver-magie-p2/attributes02.png[alt="Customize attributes", align="center"]

**Neue Attribute**

Wozu braucht man das? Wir verlinken regelmässig aus der Antwort einer Objektabfrage zu anderen Fachanwendungen. Ein gutes Beispiel sind die Grundstücke. Klickt man auf das Grundstück, wird zusätzlich ein Link auf die Grundbuch-Webanwenwendung gerendert. Dieser Link soll nicht Bestandteil der eigentlichen Daten sein und er muss dynamisch sein. D.h. Der Query-Parameter des Links ändert sich bei jedem Grundstück, damit man direkt beim angewählten Grundstück in der Fachanwendung landet. Stand heute machen wird das mit einem zusätzlichen, speziellen Jinja-Template. Mit _GeoServer_ geht das einfacher: neue Attribute können mit &laquo;Add attribute&raquo; hinzugefügt werden. Mit den bereits erwähnten Filterfunktionen und dem Zugriff auf andere Attribute (hier &laquo;egrid&raquo;) kann der Link einfach zusammengestöpselt werden:

image::../../../../../images/geoserver-magie-p2/attributes03.png[alt="Customize attributes", align="center"]

**Objekt-ID und geklickte Koordinate**

Wir haben einen eigenen Report-Service, der Zusatzinformationen zu Objekten als PDF oder Excel zurückliefert. Dem Report-Service muss man die Objekt-ID (des geklickten Objekts) und/oder die geklickte Koordinate übergeben. Was der Report-Service dann man macht, ist ihm überlassen. Heute können wir in unserer Administrationsanwendung die Reports direkt einem WMS-Layer zuweisen. Mit _GeoServer_ würde man den Link wie oben als zusätzliches Attribut erfassen. Was aber noch fehlt, ist die geklickte Koordinate. Diese müssen als Platzhalter im Link erfasst werden und können anschliessend im Freemarker Template zur Laufzeit berechnet werden. Im Freemarker Template stehen gewisse Informationen immer zur Verfügung. So z.B. die GetFeatureInfo-Request-URL. Aus dieser lässt sich die geklickte Koordinate berechnen und dem Link hinzufügen. Das kann im globalen Template gemacht werden.

**Fotos rendern**

Im globalen Templaten kann geprüft werden, ob eine Link auf ein Foto zeigt. Mehr oder weniger muss nur die Endung geprüft werden. Ist es keine Foto, wird nur der Link gerendert.

**JSON rendern**

Objekte weisen bei uns manchmal Attribute auf, deren Inhalt JSON ist. Das rührt daher, dass einem Objekt z.B. mehrere Dokumente zugewiesen sind. Das lösen wir so, dass wir diese unbekannte Anzahl an Dokumenten als JSON im Attribut kodieren. In der GetFeatureInfo-Antwort soll aber kein JSON-String stehen, sondern wie alle anderen Attribute im Key-Value-Stil gerendert werden. Auch diese Anforderungen kann direkt in einem globalen Template gelöst werden. Herausfordernd ist, herauszufinden, ob es sich um JSON handelt oder um einen normalen String. Freemarker sieht für beide Fälle nur einen String (weil _GeoServer_ das bereits umwandelt). 


Ncohmals wegen HTML und JSON...




Daten werden ja häufig - den Regeln der Kunst entsprechend - in einem normalisierten und relationalen Datenmodell erfasst. Da kann die Geometrie als solches auch schon mal die Nebenrolle spielen. Häufig haben wir den Fall, dass einer Geometrie mehrere Fotos oder PDF zugewiesen werden müssen. Soweit noch nichts Aussergewöhnliches und auch die Umsetzung geht rasch: Dank https://qgis.org/[QGIS], http://interlis.ch/[INTERLIS] und dem https://github.com/opengisch/projectgenerator[QGIS-Projektgenerator] ist die Sache in kürzester Zeit modelliert und die generische Fachschale auf Knopfdruck parat.

Die Diskussion startet aber spätestens wenn man dieses normalisierte Erfassungsmodell in eine für die gebräuchlichen WMS-Softwaren (also QGIS-Server, http://geoserver.org/[GeoServer] und https://mapserver.org/[MapServer]) taugliche Struktur bringen muss. Wenn dieser normalisierte und relationale Ansatz mit QGIS-Desktop und seinen mächtigen Formularfunktionen bei der Datenerfassung noch gut funktioniert, geht das nicht mehr so wirklich mit den genannten WMS-Servern. Diese erwarten eher resp. funktionieren am besten mit flachen und &laquo;dummen&raquo; Tabellen. Man möchte ja bloss z.B. im Web GIS Client auf eine Geometrie klicken und dann soll zumindest als Link jedes Foto oder PDF aufgelistet werden. Wie so oft gibt es hier verschiedene Lösungen. Bei uns als Altlast noch häufig verbreitet: man löst es halt für jeden Layer separat in der Objektabfrage. Das heisst, dass mit einem Mischmasch aus einer Skriptsprache (PHP...) und SQL was zusammengebastelt wird, so dass die Objektabfrage etwa das liefert, was man sich vorstellt. Vorteil: man kann sich selber verwirklichen. Nachteil: man verwirklicht sich selber.

Da wir die Daten sowieso praktisch immer von einem Erfassungsmodell in ein Publikationsmodell umbauen, kann man hier das flachwalzen durchführen. Wie walze ich aber eine 1:n-Beziehung flach? Ich kann die Links zu einem String aggregieren und mit einem Komma oder, falls es der Klient richtig rendern kann, mit einem HTML-Break trennen. Das ist dann einerseits auch nur halb-schön und funktioniert nur solange es sich bei flachzuwalzenden Daten um ein einzelnes Attribut handelt (eben ein Link zu einem Foto) und nicht komplette Objekte. Klar kann man jedes Attribut des Objektes genaus so behandeln aber das führt dann wirklich ins Nirwana.

Und hier kommt JSON ins Spiel. Beim Datenumbau aggregiere ich die Objekte zu einem JSON-Array. Am einfachsten kann man das an einem konkreten Beispiel erläutern: Unser kantonales Nutzungsplanungsmodell orientiert sich am Bundesmodell. Dieses wiederum am https://www.cadastre.ch/de/manual-oereb/publication/instruction.detail.document.html/cadastre-internet/de/documents/oereb-weisungen/Rahmenmodell-de.pdf.html[ÖREB-Rahmenmodell]. Jeder Geometrie wird ein Zonentyp zugewiesen. Jedem Zonentyp können mehrere Dokumente zugewiesen sein. Und um es noch spannender zu machen, gibt es diese Selbsreferenzierung der Dokumente auf sich selber. Als Übergangslösung bis zur Einführung des ÖREB-Katasters möchte man mit einem Klick im Web GIS Client auf eine Geometrie die wichtigsten Informationen präsentiert bekommen, d.h. neben dem Zonentyp sicher sämtliche dazugehörigen Dokumente.

Die Tabelle im Publikationsmodell hat jetzt mindestens eine Geometriespalte, eine Spalte mit dem Zonentyp und eben eine Spalte vom Typ JSON. In dieser Spalte sind sämtliche Dokumente, die für diesen Typ gültig sind als JSON-Array kodiert (Attribut &laquo;dokumente&raquo;):

image::../../../../../images/geoserver-magie-p1/grundnutzung-json.png[alt="Grundnutzung", align="center"]

Wenn man nun ein GetFeatureInfo auf diesen Layer absetzt, muss man sich zuerst entscheiden, was man vom WMS-Server retourniert haben will. Ob die Spezifikation überhaupt ein zwingendes Outputformat vorgibt, entzieht sich meiner Kenntnis, kann aber http://portal.opengeospatial.org/files/?artifact_id=1081&version=1&format=pdf[hier] oder http://portal.opengeospatial.org/files/?artifact_id=14416[hier] nachgelesen werden. Typischer Vertreter der Outputformate sind GML, HTML oder Text. Für jedes dieser Formate wird das JSON-Attribut standardmässig von GeoServer als String ausgeliefert. Somit hätte man noch nicht viel gewonnen. In QGIS sieht das so aus:

image::../../../../../images/geoserver-magie-p1/getfeatureinfo-feature.png[alt="GetFeatureInfo Feature", align="center"]

Entscheidet man sich, dass das Rendering des GetFeatureInfo-Requests auf dem Server und nicht auf dem Client geschehen soll, kann man HTML als Outputformat wählen. Standardmässig kommt hier in GeoServer eine relativ hässliche Tabelle. Aber jetzt kommt eben die Magie: Mit https://freemarker.apache.org/[Freemarker-Templates] kann ich was Schönes selber http://docs.geoserver.org/stable/en/user/tutorials/freemarker.html[zusammenbasteln]. Der Fokus liegt aber in meinem Fall weniger in &laquo;schön&raquo;, sondern dass ich eben das JSON-Array selber prozessieren kann.

Freemarker ist eine Template Engine, um Text-Output zu generieren. Für die GetFeatureInfo-Templates werden ein Header-, ein Content- und ein Footer-Template benötigt. &laquo;Nomen est Omen&raquo; in diesem Fall. Da man in unserem Fall HTML generieren will, steht im Header hauptsächlich CSS und der Beginn eines HTML-Dokumentes usw. Der Footer schliesst das sauber ab. Im Content-Template kann man das eigentliche Präsentieren des Features abhandeln:

[source,html,linenums]
----
<table class="featureInfo">
  <caption class="featureInfo">Zonenplan: Grundnutzungen</caption>
  <col style="width:30%">
  <col style="width:70%">
  <#list features as feature>
    <#assign attrs = feature.attributes >
    <tr>
      <td><strong>Typ-Bezeichnung:</strong></td>
      <td>${attrs.typ_bezeichnung.value}</td>
    </tr>
    <tr>
      <td><strong>Kantonaler Typ:</strong></td>
      <td>${attrs.typ_kt.value}</td>
    </tr>
    <tr>
      <td><strong>Kommunaler Typ:</strong></td>
      <td>${attrs.typ_code_kommunal.value}</td>
    </tr>
    <tr>
      <td><strong>Verbindlichkeit:</strong></td>
      <td>${attrs.typ_verbindlichkeit.value}</td>
    </tr>
    <tr>
      <td><strong>Rechtsstatus:</strong></td>
      <td>${attrs.rechtsstatus.value}</td>
    </tr>
    <tr>
      <td><strong>Publiziert ab:</strong></td>
      <td>${attrs.publiziertab.value?date('MM/dd/yy')?string["dd. MMMM yyyy"]}</td>
    </tr>
    <tr>
      <td colspan="2"><strong>Dokumente:</strong></td>
    </tr>
        <#if "${attrs.dokumente.value}" != "">
          <#assign documents = "${attrs.dokumente.value}"?eval>
          <#list documents as document>
              <tr>
                <td style="font-weight:500;padding-left:2em;padding-top:0em;">Titel:</td>
                <td style="padding-top:0em;">${document.titel}</td>
              </tr>
              <tr>
                <td style="font-weight:500;padding-left:2em;padding-top:0em;">Offizieller Titel:</td>
                <td style="padding-top:0em;">${document.offiziellertitel}</td>
              </tr>
              <tr>
                <td style="font-weight:500;padding-left:2em;padding-top:0em;">Nummer:</td>
                <td style="padding-top:0em;">${document.offiziellenr}</td>
              </tr>
              <tr>
                <td style="font-weight:500;padding-left:2em;padding-top:0em;">Rechtsstatus:</td>
                <td style="padding-top:0em;">${document.rechtsstatus}</td>
              </tr>
              <tr>
                <td style="font-weight:500;padding-left:2em;padding-top:0em;">Publiziert ab:</td>
                <td style="padding-top:0em;">${document.publiziertab?date('yyyy-MM-dd')?string["dd. MMMM yyyy"]}</td>
              </tr>
              <tr>
                <td style="font-weight:500;padding-left:2em;padding-top:0em;">Link:</td>
                <td style="padding-top:0em;"><a href="${document.textimweb_absolut}" target="_blank">${document.textimweb_absolut}</a></td>
              </tr>
              <tr>
                <td>&nbsp;</td>
                <td></td>
              </tr>
          </#list>
        <#else>
          &nbsp;
        </#if>
  </#list>
</table>
<br/>
----
(Sorry für das hässliche HTML.)

Das Meiste ist ziemlich vorhersehbar. Wichtig ist die Zeile 35, wo mit `<#assign documents = "${attrs.dokumente.value}"?eval>` aus dem JSON-Array-String für Freemarker eine Liste gemacht wird, die man iterieren kann. Heikel resp. wohl ein Bug ist der Umstand, dass JSON-null-Werte zu einer Exception führen. Hier kann man als Workaround beim Datenumbau in PostgreSQL die Funktion `json_strip_nulls()` verwenden, die Attribute mit null-Werten wegputzt.

Das Resultat kann sich meines Erachtes sehen lassen:

image::../../../../../images/geoserver-magie-p1/getfeatureinfo-html-chrome.png[alt="GetFeatureInfo Chrome", align="center"]

In QGIS funktioniert es auch:

image::../../../../../images/geoserver-magie-p1/getfeatureinfo-html.png[alt="GetFeatureInfo HTML", align="center"]

Da wir auch unsere Publikationsmodelle mit INTERLIS modellieren, haben wir das Dokumente-Attribut als reinen Text modelliert. In Zukunft kann man das dank einer Erweiterung von https://github.com/claeis/ili2db[_ili2db_] sauberer machen. Die Dokumente werden als BAG OF STRUCTURES modelliert und mit einem Meta-Attribut versehen. Dann weiss _ili2db_, dass es diese BAG OF STRUCTURES als JSON-Attribut in der relationalen Datenbank abbilden muss. Diese Erweiterung wird Ende 2018 verfügbar sein.