= INTERLIS leicht gemacht #59 - INTERLIS IDE
Stefan Ziegler
2025-10-19
:jbake-type: post
:jbake-status: published
:jbake-tags: INTERLIS,Java,ili2c,LSP,Theia,IDE
:idprefix:

Ich denke, dass man jetzt aufhören sollte mit dem Projekt &laquo;neuer UML/INTERLIS Editor&raquo;. Warum noch viel Geld und Stunden verlochen, wenn es - tadaaa - meine https://edigonzales.github.io/interlis-ide/[_INTERLIS IDE_] gibt.

Ich habe bereits für _jEdit_ ein https://blog.sogeo.services/blog/2025/09/17/interlis-leicht-gemacht-number-56.html[INTERLIS-Plugin] geschrieben und dann feststellen müssen, dass (a) die Akzeptanz eher ein Kampf wäre und (b) Visual Studio Code schon auch Vorteile hat. Es gibt jedoch ein sehr grosses Aber! Die ganze Entwicklung von Visual Studio Code ist stark von Microsoft abhängig. Und wenn das die meisten Digitalisierungs-&laquo;Profis&raquo; etc. nicht stört, mich tut es nachhaltig. Und darum war ich positiv überrascht, dass es mit https://theia-ide.org/[_Eclipse Theia_] einen kompatiblen Editor gibt. Er verwendet im Frontend sogar den gleichen Editor wie Visual Studio Code aber _Theia_ selber ist mehr Framework als fertiges Produkt. Die _Theia IDE_ ist also ein Produkt, das auf dem _Theia_ Framework aufsetzt. Die Extensions von Visual Studio Code sind kompatibel. Nichts sprach also gegen die Portierung des jEdit-Plugins in eine VSCode-Extension.

Um das als VSCode-Extension anständig zu machen, muss man einen Language Server implementieren und darum eine kleine Extension bauen. Den Language Server kann im eigentlich in irgendeiner Sprache programmieren. Er muss am Ende des Tages einfach auf der Zielplattform, wo auch VSCode läuft, ausführbar sein. Weil ich unbedingt wollte, dass sich die INTERLIS-Datenmodelle mit dem offiziellen INTERLIS-Compiler _ili2_c prüfen kann, musste es Java sein. Damit der Anwender sich nicht um eine Java Runtime auf seinem PC kümmern muss, liefere ich neben dem Language Server auch gleiche eine möglichst kleine JRE mit. Und zwar für hoffentlich alle gängigen Betriebssysteme. Die Extension kümmert sich um das Starten und Beenden des Language Servers. Davon merkt der Anwender nichts. Die Kommunikation zwischen Editor und Language Server läuft via STDIO und JSON. Theoretisch funktioniert der Language Server auch mit anderen Editoren / IDE wie z.B. _Eclipse_ und _Netbeans_. Es gibt gewisse Standardfunktionen die funktionieren werden. Implementiert der Language Server zusätzliche Befehle, müsste ein anderer Client diese auch implementieren, sonst bringen sie nichts. Soweit die Theorie.



lsp4j

und ja hat sicher noch viele Bugs.

read-only Der Jurist, der was im Objektkatalog ergänzt. Da lebe ich in einem anderen Universum. Diesen Jurist gibt es bei uns nicht (nicht dass sich schlecht wären, aber der Usecase!?)


Zukunft sieht sehr gut aus:
- collaboration (ohne microsoft)
- online im Browser
- mächtigere Erweiterungsmöglichkeiten



Ich glaube ja immer noch, dass die einfachen Dinge in INTERLIS nicht schwierig zu modellieren sind. Die Syntax scheint mir sehr überschaubar. Schwieriger wird es bei komplizierteren Constraints. Das liegt mir nicht. Die grösste Herausforderung ist sowieso ein gutes Modell zu schreiben, das der Fragestellung gerecht wird und wirklich weniger die einfache Syntax.

&laquo;Aber&raquo; wäre es im momentanen KI-Hype nicht doch schön, man könnte ein LLM beauftragen, es solle eine Klasse soundso mit den und den Attributen eines bestimmten Typs erstellen? Ich habe die Erfahrung gemacht, dass z.B. ChatGPT zwischenzeitlich recht gut &laquo;INTERLIS kann&raquo;. Interessanterweise kennt es auch den INTERLIS-Compiler recht gut, um damit zu programmieren. Aber wie kann man sicher sein, dass da nicht kompletter Mist rauskommt, wenn man Modellierungsfragen stellt? Man kann dazu z.B. einen MCP-Server verwenden. Was ist das?

MCP (Model Context Protocol) ist ein offenes Protokoll, mit dem KI-Clients (z. B. Chat- oder Agent-Apps) sicher und standardisiert auf externe MCP-Server zugreifen. Ein MCP-Server stellt dem Modell Tools, Ressourcen/Daten und Prompts bereit. Der Client entdeckt die Fähigkeiten des Servers, ruft Tools auf, liest Ressourcen und erhält Ergebnisse – transportagnostisch (z. B. stdio oder WebSocket).

image::../../../../../images/interlis_leicht_gemacht_p58/mcp-sequence.png[alt="ili2mermaid", align="center"]

Den MCP-Server habe ich mit _Spring Boot_ und _Spring AI_ umgesetzt. Beim Austausch via STDIO ist wirklich darauf zu achten, dass nichts nach STDIO geloggt wird, vor allem auch beim Hochfahren der Anwendung nicht. Austausch via STDIO bedeutet, dass das Teil lokal laufen muss. Es gibt noch die Möglichkeit den Austausch via WebSocket stattfinden zu lassen. Im letzteren Fall poppen oft Fragen hinsichtlich Authentifizierung und Autorisierung auf.

Ich verzichte hier auf das Auflisten sämtlicher Tools, die der MCP-Server unterstützt. Ein vollständige Liste findet sich im https://github.com/edigonzales/interlis-mcp/blob/main/docs/USER_GUIDE.md#tool-reference[User Guide] des Github-Repos.

Wie kann man den Server nun benutzen? Als wichtigster Reminder: Es braucht schon noch eine KI, also ein LLM. Als erstes hat meines Wissens _Claude Desktop_ MCP unterstützt. Hier muss man die Datei `claude_desktop_config.json` konfigurieren. Diese liegt unter macOS im Ordner `~/Library/Application Support/Claude` und sieht z.B. so aus:

[source,json,linenums]
----
{
    "mcpServers" : {
        "sogis-mcp" : {
            "command" : "/Users/stefan/.sdkman/candidates/java/21.0.4-graal/bin/java",
            "args" : [
                "-jar",
                "/Users/stefan/sources/sogis-mcp-poc/build/libs/sogis-mcp-poc-0.0.1-SNAPSHOT.jar"
            ]
        },
        "interlis-mcp": {
            "command" : "/Users/stefan/.sdkman/candidates/java/21.0.4-graal/bin/java",
            "args": ["-jar", "/Users/stefan/sources/interlis-mcp/build/libs/interlis-mcp.jar"],
            "env": {
                "JAVA_TOOL_OPTIONS": "-Xms512m -Xmx512m"
            }
        } 
    }
}
----

Hier ein Beispiel mit _Claude Desktop_:

image::../../../../../images/interlis_leicht_gemacht_p58/mcp_claude.png[alt="mcp claude", align="center"]

Man erkennt gut den strukturierten Request, den der Client an den MCP-Server macht:

[source,json,linenums]
----
{
  `name`: `Gebaeude`,
  `oidDecl`: `OID AS UUIDOID`,
  `attrLines`: [],
  `extendsFqn`: ``,
  `isAbstract`: false
}
----

Was genau übermittelt werden kann und in welcher Struktur, weiss der Client, weil der MCP-Server seine Tools beschreibt und diese Beschreibung auch ausliefert (ähnlich GetCapabilities von WMS o.ä.).

Auch Visual Studio Code unterstützt MCP-Server. Hinzufügen kann man sie über den `MCP: Add Server` Befehl. Das Hinzufügen geschieht anschliessend interaktiv. Am Ende landet die Konfig doch wieder in einer JSON-Datei, die man auch selber bearbeiten kann. Out-of-the-box ist in VSCode Copilot der Client. Hier habe ich noch nicht ganz den Durchblick. Ich glaube, man hat ein paar ChatGPT-Requests geschenkt, anschliessend muss der Rubel rollen. Erwähnenswert ist vielleicht folgendes (mit viel Halbwissen): Man kann sich einen eigenen Chatmodus erstellen (siehe Screenhot ganz unten rechts &laquo;SuperAgent&raquo;). Ich habe dies machen müssen, um Copilot dazu zu bringen, dass er bei INTERLIS-Fragen immer meinen MCP-Server fragt und nicht selber etwas wurstelt.

[source,json,linenums]
----
---
description: 'Description of the custom chat mode.'
tools: ['interlis-mcp']
---
Bitte verwende für alle INTERLIS-Modellbausteine immer den MCP-Server.
----

image::../../../../../images/interlis_leicht_gemacht_p58/mcp-vscode.png[alt="mcp vscode", align="center"]

Neben der grundsätzlichen Sinnhaftigkeit, gibt es auch ein paar Nachteile: (1) Ich denke, dass es relativ aufwändig wird, wenn man praktisch die ganze INTERLIS-Sprache so umsetzen will. Aber vielleicht ist es auch bloss Fleissarbeit und gute Prompts. Und (2): Weil der MCP-Server nicht immer komplette Modelle zurückliefert resp. erstellt, kann man diese Konstrukte nicht mit _ili2c_ prüfen. Entweder baut man sich einen &laquo;Snippet-Compiler&raquo; oder man macht z.B. um eine vom Server erstellt Klasse noch ein generisches &laquo;Mantel-Modell&raquo; drum und prüft dann mit _ili2c_.


Links:

- https://github.com/edigonzales/interlis-mcp