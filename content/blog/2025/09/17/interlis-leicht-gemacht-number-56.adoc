= INTERLIS leicht gemacht #56 - Einfacher modellieren mit jEdit    
Stefan Ziegler
2025-09-16
:jbake-type: post
:jbake-status: published
:jbake-tags: INTERLIS,Java,jEdit,ili2c
:idprefix:

Wir modellieren INTERLIS-Modelle mit dem http://www.umleditor.org/[_UML/INTERLIS-Editor_]. Warum wir das so machen, weiss ich nicht mehr recht. Wahrscheinlich wir wir damals glaubten, dass man das halt so macht Auch wenn das Ding bereits 2016 eher unmodern wirkte. Aber gegen unser neues Zeit- und Leistungserfassungstool scheint der _UML/INTERLIS-Editor_ als hätte ihn Jony Ive persönlich designed. Aber das ist eine ganz andere Geschichte. Zurück zu den wichtigen Dingen des Lebens.

Nach all den Jahren können wir glaub sagen, was uns wichtig ist: Die Datenmodelle sollen immer gleich formatiert sein und es muss eine visuelle Repräsentation in Form eines UML-Klassendiagramms vorhanden sein resp. einfach ableitbar sein. Nicht zwingend notwendig ist die Erstellung des Datenmodelles mit einem &laquo;Klick&raquo;-Editor. Die wirklichen Ur-Beweggründe ich nicht mehr, warum es den _UML/INTERLIS-Editor_ überhaupt gibt aber mich dünkt der Mehrwert / die Unterstützung bei der Modellierung marginal bis nicht vorhanden bis kontraproduktiv. Die Syntax von INTERLIS für die einfachen Fälle (also Modell, Topic, Klasse und Attribute) ist ja wirklich trivial. Mit einem Text-Editor, der mich noch ein wenig unterstützt, bin ich garantiert schneller als jemand, der gefühlte 1000 Mausklicks machen muss. Wird es komplizierter (beginnt bei mir bereits bei Assoziationen: Mmmh, wohin gehört welche Rolle?), muss ich sowieso in die Modelldatei nachschauen gehen. Und wenn es wirklich grausam wird (komplexe Constraints), müsste ein guter UML/INTERLIS-Editor _wirklich_ gut sein, damit ich einen Mehrwert habe.

Zusammengefasst: Mir reicht ein Text-Editor mit Syntax-Highlighting, der die Syntax meines INTERLIS-Modelles überprüft (kompiliert) und mir eine read-only UML-Darstellung erstellt. https://blog.sogeo.services/blog/2025/07/22/interlis-leicht-gemacht-number-53.html[In einem älteren Beitrag] habe ich gezeigt, wie ich eine VSCode-Extension für den INTERLIS-Compiler _ili2c_ programmiert habe. Technisch ist es nicht gerade straight forward mit der native shared library aber machbar. Stärker wiegt aber der Umstand, dass _VSCode_ mehr oder weniger komplett von Microsoft kontrolliert wird. Und das fand ich dann weniger gut. Schon nur, weil wir bereits mit Github zu Microsoft-Jünger geworden sind. Mit https://www.jedit.org/[jEdit] steht jedoch ein Veteran bereit, der bereits seit Jahren Syntax-Highlighting für INTERLIS bietet und zudem in Java geschrieben ist. Damit dürfte die Entwicklung eines Plugins für INTERLIS (hauptsächlich für _ili2c_) sehr gut machbar sein. Der Nachteil von _jEdit_ ist sicher seine kleine Community und dass er nicht das https://en.wikipedia.org/wiki/Language_Server_Protocol[Language Server Protocol] unterstützt. Weil ich das doch ziemlich gut finde, habe ich mich schlau gemacht und mit https://theia-ide.org/[Eclipse Theia] eine Alternative für _VSCode_ gefunden. Jedenfalls habe ich aber ein recht umfangreiches INTERLIS-Plugin für _jEdit_ geschrieben aber vielleicht ist nach _jEdit_ vor _Eclipse Theia_. Who knows?

_JEdit_ ist https://www.jedit.org/users-guide/writing-plugins-part.html[einfach erweiterbar] und es gibt https://plugins.jedit.org/list.php[viele Plugins], wo man schauen kann wie es gemacht wird. Was ich gut fand, ist die Einfachheit: 

[source,ini,linenums]
----
plugin.ch.so.agi.jedit.InterlisPlugin.menu=compileCurrentFile \
    toggleCompileOnSave \
    prettyPrintCurrentFile \
    interlis-collect-keywords \
    interlis-uml-show \
    interlis-uml-show-static \
    interlis.create-object-catalog

compileCurrentFile.label=Compile current file
toggleCompileOnSave.label=Toggle compile on save
prettyPrintCurrentFile.label=Pretty print current file
interlis-uml-show.label=Show UML diagram (interactive)
interlis-uml-show-static.label=Show UML diagram (static)
#interlis-uml-toggle.label=Toggle UML diagram
interlis-collect-keywords.label=Collect model tags
interlis.create-object-catalog.label=Export object catalog (.docx)
----

Dieser Eintrag in einer Properties-Datei erzeugt mir folgenden Menueintrag:

image::../../../../../images/interlis_leicht_gemacht_p56/jedit-menu.png[alt="jedit-menu", align="center"]

So einfach geht es eigentlich weiter. Es gibt auch eine Art Dependency Injection, wenn man sich auf andere Plugins abstützt und eine Implementierung einer Konsolenshell speziell für INTERLIS machen will. JEdit hat auch eine praktische Funktion wie eigene Fenster an das Hauptfenster gedockt werden kann. Die meisten dieser Dinge lassen sich einfach in einer zentralen Properties-Datei oder in verschiedenen XML-Dateien steuern.

Was habe ich alles für INTERLIS implementiert? Als allererstes habe ich das Syntax-Highlightung für INTERLIS 2.4 upgedatet. Dabei habe ich eine kleine funktionale Änderung bei den Kommentare vorgenommen. Neu werden Metaattribute separat behandelt. Die Farben wiederum sind nicht Bestandteil der Konfiguration, sondern kann individuell in _jEdit_ vorgenommen werden.

Als zweites wollte ich die Syntax des Modells kontrollieren indem ich das Modell mit _ili2c_ kompiliere.


_Ili2pg_ hat bekanntlich ein Wahnsinns-GUI:

image::../../../../../images/interlis_leicht_gemacht_p55/ili2pg-gui.png[alt="ili2pg-gui", align="center"]

Und wenn das neue GUI nicht zu _ili2pg_ kommt, muss _ili2pg_ zum neuen GUI kommen. Und das &laquo;neue&raquo; GUI ist https://dbeaver.io/[_dbeaver_]. Ich denke, bei mir gab es wie zwei Auslöser ein ili2pg-dbeaver-Plugin zu schreiben: Ich hatte bereits vor längerer Zeit die Idee, dass es eigentlich ganz praktisch wäre, wenn man auf Knopfdruck Daten in einer PostgreSQL-Datenbank mit _ilivalidator_ resp. _ili2pg_ prüfen könnte. Und als ein Mitarbeiter vor kurzem meinte, dass er Daten mit _ili2pg_ via Kommandozeile nicht aus der Datenbank exportieren kann, war der Zeitpunkt für mich gekommen, das anzupacken. Natürlich mit der arroganten Meinung, dass ich dafür sicher nicht mehr Zeit braucht, als der Mitarbeiter für den Export (was sich natürlich als eine totale Fehleinschätzung erwies).

&laquo;Im Prinzip&raquo; und &laquo;eigentlich&raquo; müsste das doch ganz schnell gehen. Beide Anwendungen sind in Java geschrieben. Wie schwer kann das noch sein? Die Antwort ist: ziemlich schwer. Und zwar nicht wegen der eigentlichen Business-Logik. Das habe ich schon ein paar Mal gemacht (also Schema anlegen, Daten importieren und exportieren und solches Zeugs). Sondern das ganze Drumherum, also das eigentliche Plugin. Es ist ein schönes Beispiel dafür, dass man nicht nur die Programmiersprache kennen muss, sondern das ganze Ökosystem, um erfolgreich und effizient entwickeln zu können. 

Der Stolperstein hier ist wie ein Plugin für _Eclipse_ (_dbeaver_ ist nichts Anderes als eine Eclipse-Anwendung) gepackt, bereitgestellt und installiert werden muss. Eclipse-Plugins sind https://en.wikipedia.org/wiki/OSGi[OSGi]-Bundles (plus noch ein paar spezifische Eclipse-Sachen). OSGi-Bundles sind Module für die Java-Welt: jedes Bundle ist ein JAR mit Metadaten (Manifest), das genau beschreibt, welche Pakete es bereitstellt und welche es benötigt. Dadurch können Module dynamisch geladen, gestartet, gestoppt und aktualisiert werden, ohne die gesamte Anwendung neu zu starten. Das Ganze stammt aber aus einer andere Epoche, ist zwar mächtig, aber nicht sonderlich etwicklerfreundlich (dünkt mich). Es war für mich eine ziemliche Herausforderung eine Entwicklungsumgebung so hinzugkriegen, damit ich relativ effizient programmieren konnte. Hot- resp. Livereload ist da nicht, resp. habe ich nicht hingekriegt. Das Zückerchen gab es dann am Schluss: wie stellt man nun so ein Plugin bereit? Es sind sogenannte Update-Sites (oder Repositories). Leider ist das wiederum auch nicht so trivial wie ein Maven Repository. Fazit hier: Mein Projekt ist momentan ein Eclipse-Projekt (kein Maven- oder Gradleprojekt) und ich muss es noch manuell deployen. 

Interessanter als mein Gejammer sind sicherlich die Features des Plugins. Wobei wir bei der Installation anfangen müssen. Wie soeben erwähnt, müssen die Plugins über eine Update-Site installiert werden. Ich habe für mein Plugin eine solche Update-Seite unter der URL https://dbeaver.sogeo.services/updates erstellt. In _dbeaver_ muss man unter `Help` - `Install New Software` die Update-Site angeben und kann anschliessend das ili2pg-Plugin installieren:

image::../../../../../images/interlis_leicht_gemacht_p55/ili2pg-install.png[alt="ili2pg-install", align="center"]

Man muss verschiedenen Dingen &laquo;trusten&raquo;, so auch meiner Update-Seite. Nach einem Restart von _dbeaver_ steht das Plugin zur Verfügung. Das Plugin macht sich zum ersten Mal bemerkbar, wenn ich mit der rechten Maustaste auf ein Datenbank-Icon klicke:

image::../../../../../images/interlis_leicht_gemacht_p55/ili2pg-create-schema.png[alt="ili2pg-create-schema", align="center"]

Aus Bequemlichkeit habe ich im GUI nicht jede Option nachgebildet, sondern nur die absolut Notwendigsten. Nämlich eine Option für den Schemanamen und eine Option für eine https://blog.sogeo.services/blog/2023/05/10/interlis-leicht-gemacht-number-35.html[INI-Datei]. Die INI-Datei beinhaltet alle Infos, die _ili2pg_ benötigt, um eine Schema anzulegen:

[source,ini,linenums]
----
[ch.ehi.ili2db]
models=SO_Hoheitsgrenzen_Publikation_20170626
nameByTopic=true
defaultSrsCode=2056
createFk=true
createFkIdx=true
createMetaInfo=true
createUnique=true
createNumChecks=true
createTextChecks=true
createDateTimeChecks=true
createEnumTabs=true
strokeArcs=true
----

image::../../../../../images/interlis_leicht_gemacht_p55/ili2pg-create-schema-gui.png[alt="ili2pg-create-schema-gui", align="center"]

Die Logmeldungen erscheinen in einem speziellen &laquo;ili2pg&raquo;-Tab in der Konsole:

image::../../../../../images/interlis_leicht_gemacht_p55/ili2pg-create-schema-finished.png[alt="ili2pg-create-schema-finished", align="center"]

Will man Daten importieren, muss ich das soeben erstellte Schema anwählen und wiederum die rechte Maustaste klicken. Jetzt erscheinen mehrere Befehle:

image::../../../../../images/interlis_leicht_gemacht_p55/ili2pg-befehle.png[alt="ili2pg-befehle", align="center"]

Für den Datenimport werden mehr Optionen benötigt, um sinnvolle Imports machen zu können. Wahrscheinlich fehlt aber noch die eine oder andere (z.B. `--replace`) Option, um wirklich production-ready zu sein. Erwähnenswert ist die Option `Model`. Man muss ili2pg immer mitteilen, welches Modell man importieren resp. exportieren will. Aus den Metatabellen wird auch nicht ersichtlich, um welches Modell es sich handelte, als man Daten importierte. Es werden gleichberechtigt sämtliche benötigten Modelle in der Tabelle `t_ili2db_model` vorgehalten. Aus diesem Grund muss der Benutzer auch immer das Modell auswählen. Ich habe es nun so gelöst, dass ich vier Modellarten ignoriere (`TYPE`, `CONTRACTED`, `REFSYSTEM` und `SYMBOLOGY`). Diese wird man nicht importieren oder exportieren wollen. Sind nach Abzug dieser Modelle noch mehrere Modelle übrig, muss der Benutzer entscheiden. Ist nur noch eines übrig, wird automatisch dieses einzige Modell für den ili2pg-Befehl verwendet.

image::../../../../../images/interlis_leicht_gemacht_p55/ili2pg-import-data.png[alt="ili2pg-import-data", align="center"]

image::../../../../../images/interlis_leicht_gemacht_p55/ili2pg-import-data-finished.png[alt="ili2pg-import-data-finished", align="center"]

Das geht nun so weiter für die restlichen Befehle des Plugins: `Export schema...`, `Export schema with options...` und `Validate schema...`. Die Einstellungen zu den Modellrepositories kann man unter `Settings` - `ili2pg` vornehmen.

Die Dokumentation des Plugin-Repos ist noch ungenügend. Aber vielleicht kann jemand das Plugin bereits gewinnbringend einsetzen.

Links:

- https://dbeaver.sogeo.services/updates/
- https://github.com/edigonzales/dbeaver-ili2pg-plugin
- https://github.com/edigonzales/dbeaver-ilitools-feature

