= ÖREB-Kataster richtig gemacht #5 - ÖREB-Webservice
Stefan Ziegler
2022-05-11
:jbake-type: post
:jbake-status: draft
:jbake-tags: ÖREB,ÖREB-Kataster,PostgreSQL,PostGIS,INTERLIS,,ili2pg,ili2db,ilivalidator,Spring Boot,XSLT,XSL-FO
:idprefix:

Der ÖREB-Webservice ist das eigentliche Herz des ÖREB-Katasters und das einzige Originäre. Trotzdem ist er im Prinzip sehr simpel. Er macht pro Aufruf ein paar Datenbankabfragen und wandelt das Resultat nach XML um. Wobei man sich um das eigentlich Formatieren nicht kümmern muss. Doch dazu später mehr. Sinnvoll erscheint mir, dass das PDF direkt aus dem XML abgeleitet wird und nicht mit zusätzlichen Datenbankabfragen gesondert hergestellt wird.

Die Basis des Webservices ist https://spring.io/projects/spring-boot[_Spring Boot_]. Ein Java-Framework, das wir bei uns für sehr vieles einsetzen. Sämtliche ÖREB-Magie geschieht praktisch in einem https://github.com/claeis/oereb-web-service/blob/master/src/main/java/ch/ehi/oereb/webservice/OerebController.java[Controller]. Der Controller nimmt die Anfragen (GetEgrid, GetExtractById, ...) entgegen und sammelt anschliessend die Daten in der Datenbank zusammen.

Die XML-Datei als solches müssen wir nicht selber formatieren, sondern verwenden https://javaee.github.io/jaxb-v2/[_JAXB_], das uns diese Arbeit abnimmt. Wir müssen bloss die Resultate aus der Datenbank in Java-Objekte umwandeln. Aus den Java-Objekten erzeugt _JAXB_ die XML-Datei selbständig. Die Java-Klassen müssen vorgängig einmalig - ebenfalls mit _JAXB_ aus dem XML-Schema erzeugt werden. Manchmal kann das auch mühsam werden, wenn - wie in in der Version 1 des Rahmenmodelles - die Geometriekodierung auf GML basiert. Dann enstehen, aufgrund der Komplexität des GML-Standards, hunderte von Java-Klassen. Die meisten natürlich für unseren Anwendungsfall völlig unnötigt. Weil in der Version 2 des Rahmenmodelles die Geometriekodierung auf INTERLIS basiert, schrumpft dies auf ein paar Klassen zusammen.

Die Umwandlung der XML-Datei in eine PDF-Datei machen wir mit https://www.w3.org/TR/xslt/[XSLT] und https://www.w3.org/wiki/Xsl-fo[XSL-FO]. Die XSL-Transformation wandelt das XML in eine &laquo;ASCII-PDF&raquo;-Datei um. Die Transformation mit XSL-FO formatiert diese &laquo;ASCII-PDF&raquo;-Datei in eine richtige PDF-Datei. XSLT ist ein lebendiger Standard, der in der Version 3 sehr mächtig ist. Sogar Browser unterstützen XSLT. Leider nur die Version 1. Trotzdem lassen sich einige sinnvolle Anwendungen für XSL-Transformationen im Browser finden, so z.B. die ilimodels.xml-Datei einer INTERLIS-Modellablage lesbarer zu gestalten: https://geo.so.ch/models/ilimodels.xml[https://geo.so.ch/models/ilimodels.xml]. XSL-FO wird leider als Standard nicht mehr weiterentwickelt. Zukünftig könnte vielleicht https://www.w3.org/TR/css-page-3/[CSS Paged Media] diese Rolle übernehmen. Jedoch gibt es immer noch lebendige XSL-FO-Softwareprojekte, die stetig weiterentwickelt werden, z.B. https://xmlgraphics.apache.org/fop/[Apache FOP], das auch wir einsetzen.

Die Umwandlung der XML-Datei in eine PDF-Datei haben wir in eine separate https://github.com/sogis/pdf4oereb[Bibliothek] ausgelagert, die vom Webservice referenziert wird. Sie unterstützt alle Landessprachen und kann mit eingebetteten Bildern oder mit WMS-GetMap-Requests umgehen. Veröffentlicht wird die Bibliothek auf https://mvnrepository.com/artifact/io.github.sogis/pdf4oereb[Maven-Central] oder als Standalone-CLI-Tool auf https://github.com/sogis/pdf4oereb/releases[Github]. Die Verwendung des CLI-Tools ist im https://github.com/sogis/pdf4oere[README.md] beschrieben. Die XML-Datei wird vor der Transformation nicht auf Schemakonformität geprüft. Dieser Schritt könnte/sollte man eventuell noch einbauen. Für einige sehr spezifische Teilprozesse mussten https://github.com/sogis/pdf4oereb/tree/master/app/src/main/java/ch/so/agi/oereb/pdf4oereb/saxon/ext[eigene XSLT-Funktionen mit Java implementiert] werden. Dabei handelt es sich vor allem um grafischen Transformationen, wie z.B. das Herstellen des Overlay-Images bestehend aus Rubberband, Massstabsbalken und Nordpfeil. Es gibt auch noch einen (quick 'n' dirty) https://github.com/edigonzales/pdf4oereb-web-service/[Webservice] mit einem hässlichen GUI und einer M2M-Schnittstelle.

Neben der http://blog.sogeo.services/blog/2022/04/18/oereb-kataster-richtig-gemacht-2.html[ÖREB-Datenbank] und dem http://blog.sogeo.services/blog/2022/04/24/oereb-kataster-richtig-gemacht-4.html[ÖREB-WMS] ist der ÖREB-Webservice die dritte Software-Komponente des ÖREB-Katasters. Die `docker-compose` https://github.com/oereb/oereb-stack/blob/main/docker-compose.yml[Datei] muss entsprechend erweitert werden. Im Rahmen dieser Blogreihe erstellen wir kein separates Dockerimage für den Webservice, sondern verwenden das Image, welches auch wir in Betrieb haben. Das https://github.com/sogis/oereb-web-service-docker/blob/master/Dockerfile.alpine[Dockerfile] zeigt die wenigen notwendigen Einstellungsmöglichkeiten. Einige der Optionen (z.B. Hintergrundkarte, ...) müssten noch als Umgebungsvariable exponiert werden, damit nicht nur der Kanton Solothurn dieses Image verwenden kann. Ergänzt werden muss die Compose-Datei um folgenden Eintrag:

```
  webservice:
    image: sogis/oereb-web-service:2
    environment:
      TZ: Europe/Zurich
      DBURL: jdbc:postgresql://db:5432/oereb
      DBUSR: dmluser
      DBPWD: dmluser
      TMPDIR: /tmp/
      DBSCHEMA: live
      MININTERSECTION: "0.1"
    ports:
      - 8080:8080
    depends_on:
      - qgis-server
      - db
```

Mit `docker-compose up` kann man die drei Container starten und falls der Webservice erfolgreich gestartet ist, erscheint unter http://localhost:8080[http://localhost:8080] die Meldung &laquo;oereb web service&raquo;. Der Webservice wird trotzdem gestartet, wenn z.B. die Datenbank-Url oder die Login-Credentials falsch sind. In diesem Fall meldet sich der Webservice jedoch &laquo;krank&raquo;. Unter dem http://localhost:8080/actuator/health[Health-Endpoint] erscheint die Meldung `"status": "DOWN"` anstelle von `"UP"`.

Falls der DB-Container seit Teil 4 gestoppt wurde, müssen wir die Daten nochmals importieren: 
```
./start-gretl.sh --docker-image sogis/gretl:latest --docker-network \
oereb-stack_default --job-directory $PWD motherOfAllTasks
```

Wurden die Daten wieder importiert, können wir einen Testrequest machen und einen E-GRID an einer bestimmen Koordinate suchen:

http://localhost:8080/getegrid/xml/?EN=2600573,1215488&GEOMETRY=true
[http://localhost:8080/getegrid/xml/?EN=2600573,1215488&GEOMETRY=true]

Sieht der Output plausibel aus, können wir mit dem eruierten E-GRID einen XML-Auszug anfordern:

http://localhost:8080/extract/xml?EGRID=CH955832730623[http://localhost:8080/extract/xml?EGRID=CH955832730623]

Auch hier gibt es nicht viel zu sagen. Im Browser sollte eine XML-Datei angezeigt werden. Der Webservice unterstützt keinen JSON-Output. Ich finde die Weisung diesbezüglich unglücklich: XML-Output ist Pflicht, JSON ist optional. Ich bin der Meinung man sollte sich auf ein Format beschränken. Stand heute würde ich klar immer noch XML vorziehen. Die Schemaunterstützung von XML ist viel erwachsener, entsprechend auch die Werkzeuge. Oftmals hört man in diesem Kontext das Argument &laquo;aber JSON ist schneller&raquo;. Gemeint ist, dass aufgrund der absoluten Dateigrösse weniger Daten vom Server an den Client geschickt werden müssen, was natürlich stimmt. Jetzt kommt ein grosses ABER: Wenn man seinen Webserver nicht komplett falsch konfiguriert hat, werden die zu sendenden Daten komprimiert. Der Grössenvorteil von JSON gegenüber XML schmilzt so natürlich ziemlich dahin. Nun sollte man für eine gute User Experience nicht bloss die Zeit für das Übertragen des Auszugs zählen, sondern vom Anfang an, d.h. vom Klicken in die Karte bis der Auszug beim Kunden ist. Somit dürfte matchentscheidender sein wie schnell das eigentliche Herstellung des Auszuges dauert. Vor allem die Datenbankabfragen inkl. Verschnitte etc. werden viel mehr ins Gewicht fallen als ein paar Kilobyte mehr, die übertragen werden müssen. Ausserdem sollten die dynamischen Client so konfiguriert sein, dass sie nicht zwingend immer auch eingebettete Bilder anfordern, sondern bloss die WMS-Requests. Denn die Bilder braucht man nicht für die Darstellung im Web GIS Client. Und das Herstellen dieser Bilder ist sehr teuer.

Ein Request mit eingebetteten Bildern funktioniert nicht (richtig):

http://localhost:8080/extract/xml?EGRID=CH955832730623&WITHIMAGES=true[http://localhost:8080/extract/xml?EGRID=CH955832730623&WITHIMAGES=true]

Es erscheint zwar eine XML-Datei im Browser aber das `IMAGE`-Element enthält bloss einen minimalen Platzhalter-Blob. Und in der Konsole, in der wir den Service mit docker-compose gestartet haben, erscheinen Fehlermeldungen: `failed to get wms image`. Was ist passiert?


**FIXME** Blob bleibt weiterhin leer.

Notfalls mit Linux-VM??

In den ÖREB-Daten wird der Darstellungsdient mitverwaltet. In den Bundesdaten steht z.B. etwas wie https://wms.geo.admin.ch/....". In den kantonalen Daten steht momentan (ausser beim KbS, weil diese Daten in einer externen Fachanwendung vorgehalten werden und diese auch das Transferfile herstellt) http://localhost/wms/oereb. Dies haben wir mit der Umgebungsvariable `ORG_GRADLE_PROJECT_geoservicesUrl` beim Import der Daten in die Datenbank  gesteuert. Weil aber der WMS-Server in der docker-compose-Datei mit dem Port 8083 exponiert ist, findet der ÖREB-Webservice den WMS-Server nicht. Und wenn man sowohl ÖREB-Webservice und WMS mit Port 80 ansprechen will, braucht man sowieso etwas wie einen https://github.com/oereb/oereb-proxy[Reverse Proxy], den wir ebenfalls in der docker-compose-Datei als Service registrieren müssen:

```
  proxy:
    image: ghcr.io/oereb/proxy:latest
    ports:
      - 80:80
    depends_on:
      - qgis-server
      - db
      - webservice
```

Vielleicht kann man einen neu hinzugefügten Service separat starten. Ich habs leider versäumt und muss die Daten nochmals importieren. Der Webservice wie auch der WMS-Server sind nun unter Port 80 erreichbar:

http://localhost/extract/xml?EGRID=CH955832730623&WITHIMAGES=true[http://localhost/extract/xml?EGRID=CH955832730623&WITHIMAGES=true]

Leider erscheinen immer noch die gleichen Fehler. Jedenfalls auf https://docs.docker.com/desktop/windows/networking/[Windows] und https://docs.docker.com/desktop/mac/networking/[macOS]. Der Grund dafür ist "localhost". Das funktioniert nicht so wie man sich das wünscht, d.h. der Webservice-Container sieht den WMS-Server immer noch nicht. Wir müssen die URL der Darstellungsdienste in den Daten ändern zu:

```
export ORG_GRADLE_PROJECT_geoservicesUrl="http://host.docker.internal:8083/wms/oereb"
```

Das




In den ÖREB-Daten wird der Darstellungsdient mitverwaltet. Im Fall unserer kantonalen Daten steht dort `http://localhost/wms/oereb`. D.h. der WMS-Server muss für den Webservice für das Herstellen der Bilder unter dieser URL erreichbar sein. Ist er aber nicht. Ein Blick in die https://github.com/oereb/oereb-stack/blob/main/docker-compose.yml[`docker-compose`-Datei] zeigt, dass der WMS-Server unter dem Port 8083 erreichbar ist. Man kann das natürlich auf 80 ändern, nur kann dann der ÖREB-Webservice nicht mehr unter dem Port 80 exponiert werden. D.h. wir brauchen einen kleinen https://github.com/oereb/oereb-proxy[Reverse-Proxy-Server], den wir ebenfalls in der docker-compose-Datei als Service registrieren müssen:

```
  proxy:
    image: ghcr.io/oereb/proxy:latest
    ports:
      - 80:80
    depends_on:
      - qgis-server
      - db
      - webservice
```

Vielleicht kann man einen neu hinzugefügten Service separat starten. Ich habs leider versäumt und muss die Daten nochmals importieren. Der Webservice wie auch der WMS-Server sind nun unter Port 80 erreichbar:

http://localhost/extract/xml?EGRID=CH955832730623&WITHIMAGES=true[http://localhost/extract/xml?EGRID=CH955832730623&WITHIMAGES=true]

Die IMAGE-Elemente beinhalten die korrekten Blobs, was man überprüfen kann, wenn man ein PDF anfordert:

http://localhost/extract/pdf?EGRID=CH955832730623[http://localhost/extract/pdf?EGRID=CH955832730623]




http://localhost:8080/getegrid/xml/?EN=2600472.81,1215445.88&GEOMETRY=true



xml vs json



Als WMS-Server verwenden wir QGIS-Server. Für die (Nicht-)Anforderungen des ÖREB-Katasters ginge aber wohl jeder halbwegs konforme WMS-Server. Als erstes müssen wir die Layer unserer Daten konfigurieren. Die Datenquelle ist die Datenbank aus http://blog.sogeo.services/blog/2022/04/18/oereb-kataster-richtig-gemacht-2.html[Teil 2], die wir im http://blog.sogeo.services/blog/2022/04/19/oereb-kataster-richtig-gemacht-3.html[Teil 3] mit Daten befüllt haben. Es gibt in der Datenbank die Schemen `stage_wms` und `live_wms`. Ersteres dient zur Verifikation der in die Katasterstruktur importieren Daten, das zweite Schema ist das eigentlich Produktionsschema. Damit die QGIS-Projektdatei aber unabhängig vom Schemennamen aufgebaut werden kann, verwenden wir nicht direkt Datenbankverbindungsparameter, sondern das sogenannte https://www.postgresql.org/docs/current/libpq-pgservice.html[Connection Service File]. Mit grosser Wahrscheinlichkeit werden zwei benötigt. Eines für das lokale Arbeiten und eines für den Betrieb, da sich die Verbindungsparameter unterscheiden. Das Service-File für das lokale Arbeiten sieht bei mir so aus:

```
[oereb]
host=localhost
port=54323
dbname=oereb
user=gretl
password=gretl
sslmode=disable
options=-c search_path=public,live_wms
```

QGIS-Desktop muss man das Service-File bekannt machen, indem man unter `Preferences` - `System` - `Environment` eine `PGSERVICEFILE`-Variable mit dem Pfad zur Datei setzt. Die erste Zeile des Service-Files ist der Name der Verbindung. In QGIS-Desktop muss man im Datenbank-Connection-Fenster einzig der Name der Verbindung eintippen:

image::../../../../../images/oerebk_richtig_gemacht_p04/qgis_pg_connection.png[alt="qgis pg connection", align="center"]

Die letzte Zeile (`options=`) bestimmt den Suchpfad von Datenbanktabellen. Weil wir wollen, dass in der QGIS-Projektdatei nur die Tabellennamen stehen aber keine Schemennamen, definieren wir einen sogenannten Suchpfad. Dieser bestimmt in welchen Schemen die Tabelle gesucht wird, wenn das QGIS-Projekt geladen wird. Wenn ich mich aber richtig erinnere, musste ich beim Zusammenstöpseln des QGIS-Projektes nachträglich im Texteditor die Schemennamen rauslöschen, weil der `search_path` nur beim Lesen des Projektes greift, wenn die Tabelle kein Schemennamen im Projekt definiert hat. Wenn man jedoch keinen Validierungsschritt verwenden will, ist das alles unnötig und die Schemennamen dürfen im Projektfile stehen.

Nach bisschen Fleissarbeit sieht es bei mir so aus:

image::../../../../../images/oerebk_richtig_gemacht_p04/qgis_layers.png[alt="qgis layers", align="center"]

Mindestens die vorgebenen Themen hat jeder Kanton. Dazu kommen kantonale ÖREB-Themen. Bei uns z.B. das Thema Einzelschutz.

Nun geht es um das Verpacken des WMS-Servers in ein Docker-Image. Als Basis-Image verwende ich https://github.com/sogis-oereb/docker-qgis-server[unser] https://hub.docker.com/repository/docker/sogis/qgis-server-base[QGIS-Server-3.16-Image]. Wir betreiben QGIS-Server in Kombination mit _Apache Webserver_ und nicht mit _nginx_. Super glücklich sind wir mit dem Image nicht. Ob aber die Kombination mit _nginx_ besser ist, ist uns auch nicht klar. Es scheint als scheiden sich hier die Geister. Uns stört aber vor allem, dass unser Image als `root` laufen muss, eine stattliche Grösse aufweist und dass niemand wirklich weiss in welcher Konfiguration man das Teil unter grosser Last in einem Kubernetes-Cluster laufen lassen soll. Aber andere Baustelle...

Auf dem Basis-Image aufbauend, müssen wir für den ÖREB-WMS nicht mehr grosse Handstände machen. Es müssen lediglich die QGIS-Projektdatei und das Servicefile reinkopiert werden. Das Servicefile in dieser Form würde man in einer Produktionsumgebung nicht reinbrennen oder dann das Image nicht öffentlich publizieren oder die Credentials mit Umgebungsvariablen injizieren. Das https://github.com/oereb/oereb-wms/blob/main/Dockerfile.qgisserver[Dockerfile]:

[source,groovy,linenums]
----
FROM sogis/qgis-server-base:3.16

LABEL maintainer="Amt fuer Geoinformation Kanton Solothurn <agi@bd.so.ch>"

# copy .qgs 
COPY qgis /data

RUN chown -R www-data:www-data /data

#pg_service.conf File
COPY conf/pg_service.conf /etc/postgresql-common/pg_service.conf
ENV PGSERVICEFILE="/etc/postgresql-common/pg_service.conf"

#sed command to change URL rewrite
RUN sed -i 's/\^\/qgis\//\^\/wms\//g' /etc/apache2/sites-enabled/qgis-server.conf

#tell apache/qgis-server where to find the pg_service.conf file
RUN echo 'SetEnv PGSERVICEFILE "/etc/postgresql-common/pg_service.conf"' > /etc/apache2/mods-enabled/env.conf

HEALTHCHECK --interval=30s --timeout=10s --start-period=60s CMD curl http://localhost
----

Erstellt wird das Image in einer Github Action und wird via https://github.com/oereb/oereb-wms/pkgs/container/oereb-wms[Github Container Registry publiziert]. Wie bei der https://github.com/oereb/oereb-db[ÖREB-Datenbank] wird sowohl ein Image für `linux/amd64` wie auch für `linux/arm64` erstellt. Weil es jedoch das Ubuntugis-Repo nur für `linux/amd64` gibt (?), wird im ARM-Image die QGIS-Version aus dem normalen Ubuntu-Repository (3.10) installiert. Für das lokale Entwickeln soweit kein Problem. Möchte man QGIS 3.16 auf auch ARM-Rechner verwenden, muss man es wohl selber kompilieren.

Zusammen mit der ÖREB-Datenbank haben wir nun schon zwei Komponenten des ÖREB-Katasters. In einem weiteren https://github.com/oereb/oereb-stack[Github-Repository] beginne ich mit einer docker-compose-Datei mit der man die Komponenten zusammen starten kann:

```
docker-compose up
```

Wichtig ist, dass er Name des Datenbank-Services im https://github.com/oereb/oereb-stack/blob/main/docker-compose.yml[docker-compose-File] gleich heisst, wie der host-Name im Servcie-File (`db`), das wir in das WMS-Image reingebrannt haben. Sonst kann sicher der WMS-Server nicht mit der Datenbank verbinden. Funktioniert alles, liefert der Server ein http://localhost:8083/wms/oereb?SERVICE=WMS&REQUEST=GetCapabilities[GetCapabilities-Dokument] zurück. Schlägt z.B. die Verbindung zur Datenbank fehl, erscheint im Browser die Fehlermeldung `Layer(s) not valid`. Daten sind aber noch keine in der Datenbank. Mit den Gretl-Jobs aus http://blog.sogeo.services/blog/2022/04/19/oereb-kataster-richtig-gemacht-3.html[Teil 3] können wir Daten einfach importieren:

[source,groovy,linenums]
----
export ORG_GRADLE_PROJECT_dbUriOerebV2="jdbc:postgresql://db/oereb"
export ORG_GRADLE_PROJECT_dbUserOerebV2="gretl"
export ORG_GRADLE_PROJECT_dbPwdOerebV2="gretl"
export ORG_GRADLE_PROJECT_geoservicesUrl="http://localhost/wms"
----

```
./start-gretl.sh --docker-image sogis/gretl:latest --docker-network oereb-stack_default --job-directory $PWD motherOfAllTasks
```

Man beachte den anderen Docker-Netzwerk-Namen und bei den &laquo;magischen&raquo; Umgebungsvariablen für _Gretl_ die leicht andere Datenbank-Url. Auch hier musste der Hostname der Datenbank angepasst werden. 

Ein paar Minuten später kann man das Werk in QGIS-Desktop anschauen:

image::../../../../../images/oerebk_richtig_gemacht_p04/qgis_wms.png[alt="qgis wms", align="center"]

Der WMS ist momentan unter der URL http://localhost:8083/wms/oereb[http://localhost:8083/wms/oereb] erreichbar. Die URL des Darstellungsdienstes ist Bestandteil der Geobasisdaten und steht auch im XML-Auszug. Sie kann auch verwendet werden, um z.B. die Bilder für das PDF herzustellen. Wenn der Darstellungsdienst nicht von einer anderen Stelle bereitgestellt wird, sondern direkt aus der ÖREB-Datenbank publiziert wird, führt das zum Umstand, dass ich je nach Umgebung (lokal, Test, Integration, Produktion) die URL des Darstellungsdienst anpassen muss. Die URL anpassen, heisst die Daten verändern. So gesehen müsste der URL eher eine Konfiguration des Katastersystems sein und nicht Inhalt der Geobasisdaten. 

Im fünften Teil geht es um den ÖREB-Webservice (DATA-Extract und statischer Auszug).
